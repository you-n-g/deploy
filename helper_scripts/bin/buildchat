#!/usr/bin/env -S uv run --no-project --with firecrawl-py --with typer --with rdagent --with pypdf --with 'xytb[crawl]>=1.3.0' python

from typing import Callable
import typer
from pathlib import Path
from rdagent.utils.agent.tpl import T
import urllib.request
import urllib.parse
import tempfile
import os
import pypdf

app = typer.Typer()


@app.command()
def explain_ws(code_fname: str = "main.py", stdout_fname: str = "stdout.txt"):
    # render template with provided code and stdout, then create a new file chat.md
    with open(code_fname, 'r') as cf:
        code_content = cf.read()
    with open(stdout_fname, 'r') as sf:
        stdout_content = sf.read()
    chat_content = T(".buildchat:explain_ws").r(code=code_content, stdout=stdout_content)
    with open("chat.md", "w") as out_f:
        out_f.write(chat_content)


@app.command()
def compare(curr_ws: Path = typer.Argument(..., help="Path to current workspace"),
            prev_ws: Path = typer.Argument(..., help="Path to previous workspace")):
    curr_ws = Path(curr_ws)
    prev_ws = Path(prev_ws)
    with (curr_ws / "main.py").open() as cf:
        curr_code_content = cf.read()
    with (curr_ws / "stdout.txt").open() as cf:
        curr_stdout_content = cf.read()
    with (prev_ws / "main.py").open() as cf:
        prev_code_content = cf.read()
    with (prev_ws / "stdout.txt").open() as cf:
        prev_stdout_content = cf.read()
    chat_content = T(".buildchat:compare").r(curr_code=curr_code_content,
                                             curr_stdout=curr_stdout_content,
                                             prev_code=prev_code_content,
                                             prev_stdout=prev_stdout_content)
    with open("chat.md", "w") as out_f:
        out_f.write(chat_content)


from firecrawl import FirecrawlApp


def firecrawl_get(url: str):
    firecrawl_app = FirecrawlApp(api_key="fc-YOUR_API_KEY", api_url="http://localhost:3002")
    scrape_result = firecrawl_app.scrape_url(url, params={'formats': ['markdown']})
    content = scrape_result["markdown"]
    return content


def meta_chat_builder(crawler: Callable):

    def chat_builder(url: str = typer.Argument(..., help="The target URL to scrape"),):
        content = crawler(url)
        with open("chat.md", "w") as out_f:
            out_f.write(T(".buildchat:web").r(markdown=content))

    return chat_builder


@app.command()
def web(url: str = typer.Argument(..., help="The target URL to scrape"),):
    return meta_chat_builder(firecrawl_get)(url)


def extract_pdf_content(pdf_path: Path | str) -> str:
    reader = pypdf.PdfReader(pdf_path)
    parts = []
    for page in reader.pages:
        parts.append(page.extract_text() or "")
    return "\n".join(parts).strip()


@app.command()
def pdf(
        url: str = typer.Argument(..., help="The PDF URL to download and convert"),
        outfile: Path = Path("chat.md"),
        with_option: bool = typer.Option(
            False,
            "-p/-P",
            "--with-option/--no-with-option",
            help="Append additional pdf-option prompt to the chat output (use -p to enable, -P to disable)",
        ),
):
    """
    Download a PDF from a URL, extract its text, and write a chat.md file.
    Optionally append additional guidance from the pdf-option template.
    """
    # Download to a temporary file
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmpf:
        tmp_pdf_path = tmpf.name

    try:
        urllib.request.urlretrieve(url, tmp_pdf_path)
        text = extract_pdf_content(tmp_pdf_path)

        content = T(".buildchat:pdf").r(text=text)
        if with_option:
            content = f"{content}\n\n{T('.buildchat:pdf-option.paper').r()}"
        with open(outfile, "w") as out_f:
            out_f.write(content)
    finally:
        # Clean up the temporary file
        try:
            os.unlink(tmp_pdf_path)
        except Exception:
            pass


def read_data(path: Path) -> str:
    ext = path.suffix.lower()
    if ext == '.pdf':
        return extract_pdf_content(path)
    elif ext == '.txt':
        with open(path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    else:
        print(f"Error: Unsupported file type '{ext}'. Only .pdf and .txt are supported.")
        raise typer.Exit(code=1)


@app.command()
def paper(
    source: Path = typer.Argument(..., help="The source file path (pdf or txt)"),
    outfile: Path = Path("chat.md"),
    with_option: bool = typer.Option(
        True,
        "-o/-O",
        "--with-option/--no-with-option",
        help="Append additional pdf-option prompt to the chat output (use -o to enable, -O to disable)",
    ),
):
    """
    Detect file type (txt, pdf) and create a chat session.
    """
    if not source.exists():
        print(f"Error: Source '{source}' not found.")
        raise typer.Exit(code=1)

    # Stage 1: Read data
    text = read_data(source)

    # Stage 2: Render to chat
    content = T(".buildchat:pdf").r(text=text)
    if with_option:
        content = f"{content}\n\n{T('.buildchat:pdf-option.paper').r()}"
    with open(outfile, "w") as out_f:
        out_f.write(content)



from xytb.crawl.weixin import get_content


@app.command()
def weixin(url: str = typer.Argument(..., help="The target URL to scrape"),):
    return meta_chat_builder(get_content)(url)


if __name__ == "__main__":
    app()
